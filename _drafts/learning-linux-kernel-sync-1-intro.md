---
layout: post
title: Linux内核学习之同步(一) 基本概念
categories: linux_kernel
tags: linux kernel sync
---

当资源需要共享时，访问者访问临界区时必须要同步，否则就会出现资源状态不一致。

# 1 问题描述

**临界资源**: 一次最多只能允许一个代码段访问的数据区域。

**临界区（critical section）**：访问临界资源的代码段，并且会由于同时访问出现潜在的不一致问题。

临界区之所以需要保护，源于访问临界区的代码通常需要执行多条指令，而且这些指令若被打断则会出现不一致的问题。一个简单的例子：

```c
/* critical section*/
int a = 0;

/* visitor */
int add()
{
	int m = a;
	m = m + 1;
	/* 如果其它代码在这里打断了此段代码，并且也调用了这个函数，那么当此代码恢复之后，此时a变成1*/
	a = m; /* 设置a为1 */
	return a;
}
```

在上面代码中，add()函数被调用了两次，但最终a的值不是2，而是1，这就是典型的同步问题。

# 2 问题初解

考虑到多个临界区不能同时访问共享资源，这就好比要求临界区代码段执行时就像执行一条指令一样：在计算机指向该段代码时，不能被打断。
即，要么指令不被执行，要么就执行完毕，是一条**原子(atomic)**指令。

可以把问题再简化一下，如果共享数据就是一个整形变量，那么如果对该变量执行的操作都是原子操作，那么同步问题也就迎刃而解了。

在单核CPU上，指令本来就是一条一条执行的，因此对整型变量的加减操作总是原子性的（在多级流水线下情况如何，有待研究）。

在SMP机器上，多个CPU共享到内存的地址总线，因此有可能出现不同的CPU同时执行访问相同内存地址的指令。这时候的指令就不是原子性的了。

绝大部分CPU都提供了硬件级别的原子操作原语。例如，在x86机器上，使用 LOCK 指令前缀可以保证在执行指令锁住地址总线，实现指令的原子性。

Linux内核也实现了原子变量atomic_t，并实现了一些原子操作的接口。

```c
typedef struct { int counter; } atomic_t;

/* 读和写操作无需同步 */
#define atomic_read(v)      ((v)->counter)
#define atomic_set(v,i)     (((v)->counter) = (i))

/* read and set 操作 */
static __inline__ void atomic_add(int i, atomic_t *v) 
{
    __asm__ __volatile__(
        LOCK_PREFIX "addl %1,%0"
        :"+m" (v->counter)
        :"ir" (i));
}

static __inline__ void atomic_sub(int i, atomic_t *v) 
{
    __asm__ __volatile__(
        LOCK_PREFIX "subl %1,%0"
        :"+m" (v->counter)
        :"ir" (i));
}

static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
{
    unsigned char c;

    __asm__ __volatile__(
        LOCK_PREFIX "subl %2,%0; sete %1"
        :"+m" (v->counter), "=qm" (c)
        :"ir" (i) : "memory");
    return c;
}
```

对于单个变量，我们已经有了解决同步问题的方案了，那么再考虑复杂点的。当要保护的资源是复杂的数据结构时，我们无法要求
CPU提供原子指令。但是我们可以使用锁。而锁则是一个原子变量。

简单来说，在进入临界区前，先对锁进行原子地 test and set 操作，如果锁未被持有，则可以持有锁，否则就无法进入临界区。

锁机制本身利用CPU提供的原子操作保证锁变量的一致性，因此它适用于SP和SMP。

# 3 内核中的同步问题

在任意时刻，内核总是要么在进程上下文中执行系统调用，要是是在中断上下文中执行中断处理程序，或者处于中断下半部中。

此外，内核起了多个内线线程（不与用户态的进程或线程关联）用于执行特定的任务，比如周期刷新磁盘高速缓存，交换旧的页，维护网络连接等等。

内核的以下特性会导致竞争出现：

1. 在进程上下文下被中断了，CPU会切换到中断上下文，跳转到中断处理例程。当中断返回时，内核会重新调度，即并保证立即运行刚刚被打断的进程。
2. 抢占式内核。内核会强制调度当前正在运行的进程，转而调度其它任务。【参考[Linux内核抢占实现机制分析](http://blog.csdn.net/sailor_8318/article/details/2870184)】
3. SMP机器上，多个CPU同时执行某段代码。
 
有关中断的学习在另外一篇文章中记录。

**Break**

先去学习Linux进程相关知识 - 2015/11/23

# 4 内核中使用的同步方法

在单核（Single Processor）系统上，任意时刻只会有一个代码段执行。因此，临界区代码只会在两种情况被打断（就有同时访问的可能）：

1. 中断程序或软中断
2. 内核抢占。

对于情况1，只需要进入临界区前禁止中断即可；对于情况2，也只需要进入临界区前禁止内核抢占。

内核抢占的实现，其实也是借助于原子变量。

首先区分出禁止内核抢占的情形，在进入这些代码段之前，对原子变量进行增1操作；在退出这些代码段后进行减1操作。
然后当内核调用schedule()进行调度时，判断这个原子变量的值是否大于0，若大于0则表示该进程当前禁止内核抢占。

# 3 SMP下的内核同步

