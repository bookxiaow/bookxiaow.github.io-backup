---
layout: post
title: TCP的连接建立
categories: 网络编程
tags: socket network
---

## 如何创建一个TCP连接

### 建立连接的API

#### Client side

1. 调用socket，生成一个套接口描述字，返回一个文件描述法fd;
2. 调用connect，成功建立连接；
3. 调用read/write收发数据。

#### Server side

1. 调用socket，生成一个套接口描述字；
2. 调用bind，将地址绑定到套接字上；
3. 调用listen，将套接字由主动模式转化为监听模式，成功后TCP状态由CLOSED变为LISTEN；
4. 调用accept，获取已建立的连接的套接字；
5. 对已连接套接字调用read/write收发数据。

### 连接建立过程

![tcp-open](/image/tcp_open.png)

TCP连接需要3路握手，由客户端调用connect()主动发起。

在Server端，只要Server程序成功调用listen()，那么Server端的状态就会从CLOSED转换为LISTEN。这时候有Client端的连接进来，内核协议栈就会发生ACK+SYN分节以响应。

这里需要明白的是，对于任何处于LISTEN状态的监听套接字，内核为它维护两个队列：

- 未完成3路握手的连接请求队列
- 已完成3路握手的连接队列

任何来自客户端的连接请求，都会先进入第一个队列，待3路握手完成后就会进入第二个队列。其中，第一个队列的大小会有限制，当队列满时，新到达的连接请求就会被内核丢弃（思考：为什么不是返回错误给客户端呢？）

> TCP是可靠连接，如果在队列满时Server端回复一个RST给客户端的话，客户端就会认为到Server不可用，可能就不会再发起连接；而如果Server端只是丢掉的话，Client迟迟收不到ACK就会重发SYN，在Server端第一个队列重新有位置时就会接受它的请求。

所以，对于Server端的程序，只要调用了listen()，其实就已经可以接受客户端连接请求了。在Client端，一旦连接成功建立，就可以收发数据了。而Server端对来自客户端连接的数据会先存储到接收缓冲区。

当然，如果Server端一直不调用accept的话，那么所有来自客户端的连接最终都会进入第二个队列，并且因为Server不去读数据，所有客户端在填满了Server端连接的接收缓冲区之后就会无法继续发送数据了。

这下可以理解`accept`函数到底干了什么了。`accept`会从已成功连接的连接队列里取出一个连接，并返回一个代表该连接的套接字描述符。

所以，在Server端存在两种套接字：监听套接字和已连接套接字。如果Server端进程只监听一个端口的话，那么就只会创建一个监听套接字。监听套接字可读（即调用accept会立即返回），就表示已经有连接成功建立。

从文件描述符的角度来看，监听套接字和已连接套接字都是一种“文件”，且都有“读缓冲区”。

- 对于已连接套接字，可读表示“接收缓冲区”有对端发送过来的数据；可写表示“发送缓冲区”有空间可以接纳要发送到对端的数据。
- 对于监听套接字，可读表示第二个连接队列里有已完成3路握手的连接；监听套接口不可写。


## 使用select/epoll实现多路复用

有了上面对监听套接口和已连接套接口的理解之后，我们就很容易地在select/epoll中同时等待这两种套接字“可读”了。

